<head>
  <title>readme.out</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="docket.css" />
</head>
<body>
  <table cellpadding="0" cellspacing="0">
      <tbody><tr><td class="docs"><h1>osc-min</h1>

<p><em>simple utilities for open sound control in node.js</em></p>

<p>This package provides some node.js utilities for working with 
<a href="http://opensoundcontrol.org/">OSC</a>, a format for sound and systems control. <br />
Here we implement the <a href="http://opensoundcontrol.org/spec-1_1">OSC 1.1</a> specification.  OSC is a transport-independent
protocol, so we don't provide any server objects, as you should be able to 
use OSC over any transport you like.  The most common is probably udp, but tcp
is not unheard of.</p>

<hr />

<h2>Installation</h2>

<p>The easiest way to get osc-min is through <a href="http://npmjs.org">NPM</a>.
After install npm, you can install osc-min in the current directory with</p>

<p><code>
npm install osc-min
</code></p>

<p>If you'd rather get osc-min through github (for example, if you're forking
it), you still need npm to install dependencies, which you can do with</p>

<p><code>
npm install --dev
</code></p>

<p>Once you've got all the dependencies you should be able to run the unit
tests with </p>

<p><code>
npm test
npm run-script coverage
</code></p>

<hr />

<h2>Examples</h2>

<h3>A simple OSC printer</h3>

<pre><code>    sock = udp.createSocket "udp4", (msg, rinfo) -&gt;
        try
            console.log osc.fromBuffer msg
        catch error
            console.log "invalid OSC packet"
    sock.bind inport
</code></pre>

<h3>Send a bunch of arguments every two seconds</h3>

<pre><code>    sendHeartbeat = () -&gt;
        buf = osc.toBuffer(
            address : "/heartbeat"
            arguments : [
                12
                "sttttring"
                new Buffer "beat"
                {type : "integer", value : 7}
            ]
        )

        udp.send buf, 0, buf.length, outport, "localhost"

    setInterval sendHeartbeat, 2000
</code></pre>

<h3>A simple OSC redirecter</h3>

<pre><code>    sock = udp.createSocket "udp4", (msg, rinfo) -&gt;
        try
            redirected = osc.applyAddressTransform msg, (address) -&gt; "/redirect" + address
            sock.send(
                redirected,
                0,
                redirected.length,
                outport,
                "localhost"
            )
        catch error
            console.log "error redirecting: " + error
    sock.bind inport
</code></pre>

<p>more examples are available in the <code>examples/</code> directory.</p>

<hr />

<h2>Exported functions</h2>

<hr />

<h3>.fromBuffer(buffer, [strict])</h3>

<p>takes a node.js Buffer of a complete <em>OSC Packet</em> and 
outputs the javascript representation, or throws if the buffer is ill-formed.</p>

<p><code>strict</code> is an optional parameter that makes the function fail more often.</p>

<hr />

<h3>.toBuffer(object, [strict])</h3>

<p>takes a <em>OSC packet</em> javascript representation as defined below and returns
a node.js Buffer, or throws if the representation is ill-formed.</p>

<hr />

<h3>.toBuffer(address, arguments[], [strict])</h3>

<p>alternative syntax for above.  Assumes this is an <em>OSC Message</em> as defined below, 
and <code>arguments</code> is an array of <em>OSC Arguments</em> or single <em>OSC Argument</em></p>

<hr />

<h3>.applyAddressTransform(buffer, transform)</h3>

<p>takes a callback that takes a string and outputs a string,
and applies that to the address of the message encoded in the buffer,
and outputs an encoded buffer.</p>

<p>If the buffer encodes an <em>OSC Bundle</em>, this applies the function to each address 
in the bundle.</p>

<p>There's two subtle reasons you'd want to use this function rather than 
composing <code>fromBuffer</code> and <code>toBuffer</code>:
  - Future-proofing - if the OSC message uses an argument typecode that
    we don't understand, calling <code>fromBuffer</code> will throw.  The only time
    when <code>applyAddressTranform</code> might fail is if the address is malformed.
  - Accuracy - javascript represents numbers as 64-bit floats, so some
    OSC types will not be able to be represented accurately.  If accuracy
    is important to you, then, you should never convert the OSC message to a
    javascript representation.</p>

<hr />

<h3>.applyMessageTransform(buffer, transform)</h3>

<p>takes a function that takes and returns a javascript <em>OSC Message</em> representation,
and applies that to each message encoded in the buffer,
and outputs a new buffer with the new address.</p>

<p>If the buffer encodes an osc-bundle, this applies the function to each message 
in the bundle.</p>

<p>See notes above for applyAddressTransform for why you might want to use this.
While this does parse and re-pack the messages, the bundle timetags are left
in their accurate and prestine state.</p>

<hr />

<h2>Javascript representations of the OSC types.</h2>

<p>See the <a href="http://opensoundcontrol.org/spec-1_0">spec</a> for more information on the OSC types.</p>

<ul>
<li><p>An <em>OSC Packet</em> is an <em>OSC Message</em> or an <em>OSC Bundle</em>.</p></li>
<li><p>An <em>OSC Message</em>:</p>

<pre><code>  {
      oscType : "message"
      address : "/address/pattern/might/have/wildcards"
      arguments : [arg1,arg2]
  }
</code></pre>

<p>Where arguments is an array of <em>OSC Arguments</em>.  <code>oscType</code> is optional.
<code>arguments</code> can be a single element.</p></li>
<li><p>An <em>OSC Argument</em> is represented as a javascript object with the following layout:</p>

<pre><code>  {
      type : "string"
      value : "value"
  }
</code></pre>

<p>Where the <code>type</code> is one of the following:</p>

<ul><li><code>string</code> - string value</li>
<li><code>float</code> - numeric value</li>
<li><code>integer</code> - numeric value</li>
<li><code>blob</code> - node.js Buffer value</li>
<li><code>true</code> - value is boolean true</li>
<li><code>false</code> - value is boolean false</li>
<li><code>null</code> - no value</li>
<li><code>bang</code> - no value (this is the <code>I</code> type tag)</li>
<li><code>timetag</code> - numeric value</li></ul>

<p>Note that <code>type</code> is always a string - i.e. <code>"true"</code> rather than <code>true</code>.</p>

<p>The following non-standard types are also supported:</p>

<ul><li><code>double</code> - numeric value (encodes to a float64 value)</li></ul>

<p>For messages sent to the <code>toBuffer</code> function, <code>type</code> is optional.
If the argument is not an object, it will be interpreted as either
<code>string</code>, <code>float</code>, or <code>blob</code>, depending on its javascript type.</p></li>
<li><p>An <em>OSC Bundle</em> is represented as a javascript object with the following layout</p>

<pre><code>  {
      oscType : "bundle"
      timetag : 7
      elements : [element1, element]
  }
</code></pre>

<p>Where the timetag is a javascript-native numeric value of the timetag,
and elements is an array of either an <em>OSC Bundle</em> or an <em>OSC Message</em>
The <code>oscType</code> field is optional, but is always returned by api functions.</p></li>
</ul></td></tr></tbody>
  </table>
</body>